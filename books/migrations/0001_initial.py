# Generated by Django 5.2.6 on 2025-09-30 08:43

import books.mixins.sync
import django.core.validators
import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Book',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('file_path', models.CharField(help_text='Full file path', max_length=1000)),
                ('file_path_hash', models.CharField(default='', editable=False, max_length=64, unique=True)),
                ('file_format', models.CharField(choices=[('epub', 'EPUB'), ('mobi', 'MOBI'), ('pdf', 'PDF'), ('cbr', 'CBR'), ('cbz', 'CBZ'), ('placeholder', 'Placeholder')], max_length=20)),
                ('file_size', models.BigIntegerField(blank=True, null=True)),
                ('cover_path', models.CharField(blank=True, help_text='Local cover file path', max_length=1000)),
                ('opf_path', models.CharField(blank=True, help_text='OPF metadata file path', max_length=1000)),
                ('first_scanned', models.DateTimeField(auto_now_add=True)),
                ('last_scanned', models.DateTimeField(auto_now=True)),
                ('is_placeholder', models.BooleanField(default=False)),
                ('is_duplicate', models.BooleanField(default=False)),
                ('is_corrupted', models.BooleanField(default=False)),
                ('is_available', models.BooleanField(default=True, help_text='Whether the book file is still available on disk')),
                ('last_scan_status', models.CharField(blank=True, help_text="Status from last scan: 'found', 'removed', 'updated'", max_length=20, null=True)),
            ],
            options={
                'ordering': ['-last_scanned', 'file_path'],
            },
        ),
        migrations.CreateModel(
            name='DataSource',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(choices=[('Filename', 'Filename'), ('EPUB', 'EPUB'), ('MOBI', 'MOBI'), ('PDF', 'PDF'), ('OPF File', 'OPF File'), ('Open Library', 'Open Library'), ('Google Books', 'Google Books'), ('Comic Vine', 'Comic Vine'), ('Open Library Covers', 'Open Library Covers'), ('Google Books Covers', 'Google Books Covers'), ('Original Scan', 'Original Scan'), ('Manual Entry', 'Manual Entry'), ('ISBN Content Scan', 'ISBN Content Scan')], max_length=50, unique=True)),
                ('trust_level', models.FloatField(default=0.5, help_text='Trust level for this source (0.0-1.0)', validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('priority', models.IntegerField(default=1, help_text='Source priority for ordering')),
                ('is_active', models.BooleanField(default=True, help_text='Whether this source is active')),
            ],
            options={
                'ordering': ['-trust_level', 'name'],
            },
        ),
        migrations.CreateModel(
            name='Genre',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, unique=True)),
                ('is_reviewed', models.BooleanField(default=False, help_text="Mark genres you've verified or finalized")),
            ],
            options={
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='Publisher',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=255, unique=True)),
                ('is_reviewed', models.BooleanField(default=False, help_text="Mark publishers you've verified or finalized")),
            ],
        ),
        migrations.CreateModel(
            name='ScanFolder',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(default='Untitled', max_length=100)),
                ('path', models.CharField(max_length=500)),
                ('content_type', models.CharField(choices=[('ebooks', 'üìò Ebooks'), ('comics', 'üñºÔ∏è Comics'), ('audiobooks', 'üîä Audiobooks')], default='ebooks', help_text='Type of content in this scan folder', max_length=20)),
                ('language', models.CharField(choices=[('en', 'English'), ('fr', 'French'), ('de', 'German'), ('nl', 'Dutch'), ('es', 'Spanish'), ('it', 'Italian'), ('pt', 'Portuguese'), ('ja', 'Japanese'), ('ko', 'Korean'), ('zh', 'Chinese'), ('ru', 'Russian'), ('pl', 'Polish'), ('he', 'Hebrew'), ('hu', 'Hungarian'), ('tr', 'Turkish'), ('ca', 'Catalan'), ('id', 'Indonesian')], default='en', max_length=10)),
                ('is_active', models.BooleanField(default=True)),
                ('last_scanned', models.DateTimeField(blank=True, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
        ),
        migrations.CreateModel(
            name='ScanStatus',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('status', models.CharField(choices=[('Pending', 'Pending'), ('Running', 'Running'), ('Completed', 'Completed'), ('Failed', 'Failed')], default='Pending', max_length=20)),
                ('progress', models.IntegerField(default=0)),
                ('message', models.TextField(blank=True, null=True)),
                ('started', models.DateTimeField(auto_now_add=True)),
                ('updated', models.DateTimeField(auto_now=True)),
                ('last_processed_file', models.TextField(blank=True, help_text='Last file path that was completely processed', null=True)),
                ('total_files', models.IntegerField(default=0, help_text='Total number of files to process')),
                ('processed_files', models.IntegerField(default=0, help_text='Number of files processed so far')),
                ('scan_folders', models.TextField(blank=True, help_text='JSON list of folders being scanned', null=True)),
            ],
        ),
        migrations.CreateModel(
            name='Series',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=200, unique=True)),
            ],
            options={
                'verbose_name_plural': 'Series',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='Author',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=200)),
                ('first_name', models.CharField(blank=True, max_length=100)),
                ('last_name', models.CharField(blank=True, max_length=100)),
                ('name_normalized', models.CharField(db_index=True, max_length=200, unique=True)),
                ('is_reviewed', models.BooleanField(default=False, help_text="Mark authors you've verified or finalized")),
            ],
            options={
                'ordering': ['name'],
                'constraints': [models.UniqueConstraint(fields=('first_name', 'last_name'), name='unique_author_name_combo')],
            },
        ),
        migrations.CreateModel(
            name='FileOperation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('operation_type', models.CharField(choices=[('rename', 'File Rename'), ('move', 'File Move'), ('create_folder', 'Folder Creation')], max_length=20)),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('completed', 'Completed'), ('failed', 'Failed'), ('reverted', 'Reverted')], default='pending', max_length=20)),
                ('original_file_path', models.CharField(blank=True, max_length=1000)),
                ('original_cover_path', models.CharField(blank=True, max_length=1000)),
                ('original_opf_path', models.CharField(blank=True, max_length=1000)),
                ('original_folder_path', models.CharField(blank=True, max_length=1000)),
                ('new_file_path', models.CharField(blank=True, max_length=1000)),
                ('new_cover_path', models.CharField(blank=True, max_length=1000)),
                ('new_opf_path', models.CharField(blank=True, max_length=1000)),
                ('new_folder_path', models.CharField(blank=True, max_length=1000)),
                ('additional_files', models.TextField(default='[]', help_text='JSON list of additional files moved')),
                ('operation_date', models.DateTimeField(auto_now_add=True)),
                ('batch_id', models.UUIDField(blank=True, help_text='Groups operations from same batch', null=True)),
                ('notes', models.TextField(blank=True)),
                ('error_message', models.TextField(blank=True)),
                ('book', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='file_operations', to='books.book')),
                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'books_fileoperation',
                'ordering': ['-operation_date'],
            },
        ),
        migrations.CreateModel(
            name='FinalMetadata',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('final_title', models.CharField(blank=True, max_length=500)),
                ('final_title_confidence', models.FloatField(default=0.0)),
                ('final_author', models.CharField(blank=True, max_length=500)),
                ('final_author_confidence', models.FloatField(default=0.0)),
                ('final_series', models.CharField(blank=True, max_length=200, null=True)),
                ('final_series_number', models.CharField(blank=True, max_length=20, null=True)),
                ('final_series_confidence', models.FloatField(default=0.0)),
                ('final_cover_path', models.CharField(blank=True, max_length=1000)),
                ('final_cover_confidence', models.FloatField(default=0.0)),
                ('final_publisher', models.CharField(blank=True, max_length=200)),
                ('final_publisher_confidence', models.FloatField(default=0.0)),
                ('language', models.CharField(blank=True, max_length=10)),
                ('isbn', models.CharField(blank=True, max_length=20)),
                ('publication_year', models.IntegerField(blank=True, null=True)),
                ('description', models.TextField(blank=True)),
                ('overall_confidence', models.FloatField(default=0.0)),
                ('completeness_score', models.FloatField(default=0.0)),
                ('is_reviewed', models.BooleanField(default=False)),
                ('has_cover', models.BooleanField(default=False)),
                ('last_updated', models.DateTimeField(auto_now=True)),
                ('book', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, to='books.book')),
            ],
        ),
        migrations.AddField(
            model_name='book',
            name='scan_folder',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, to='books.scanfolder'),
        ),
        migrations.CreateModel(
            name='ScanLog',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('timestamp', models.DateTimeField(auto_now_add=True)),
                ('level', models.CharField(choices=[('INFO', 'Info'), ('WARNING', 'Warning'), ('ERROR', 'Error')], max_length=10)),
                ('message', models.TextField()),
                ('file_path', models.CharField(blank=True, max_length=1000)),
                ('books_found', models.IntegerField(default=0)),
                ('books_processed', models.IntegerField(default=0)),
                ('errors_count', models.IntegerField(default=0)),
                ('scan_folder', models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, to='books.scanfolder')),
            ],
            options={
                'ordering': ['-timestamp'],
            },
        ),
        migrations.CreateModel(
            name='SetupWizard',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('welcome_completed', models.BooleanField(default=False)),
                ('folders_completed', models.BooleanField(default=False)),
                ('content_types_completed', models.BooleanField(default=False)),
                ('scrapers_completed', models.BooleanField(default=False)),
                ('is_completed', models.BooleanField(default=False)),
                ('is_skipped', models.BooleanField(default=False)),
                ('current_step', models.CharField(choices=[('welcome', 'Welcome'), ('folders', 'Folder Selection'), ('content_types', 'Content Type Assignment'), ('scrapers', 'Scraper Configuration'), ('complete', 'Setup Complete')], default='welcome', max_length=20)),
                ('selected_folders', models.JSONField(blank=True, default=list, help_text='List of selected folder paths')),
                ('folder_content_types', models.JSONField(blank=True, default=dict, help_text='Mapping of folders to content types')),
                ('scraper_config', models.JSONField(blank=True, default=dict, help_text='Scraper configuration settings')),
                ('started_at', models.DateTimeField(auto_now_add=True)),
                ('completed_at', models.DateTimeField(blank=True, null=True)),
                ('last_step_at', models.DateTimeField(auto_now=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='setup_wizard', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Setup Wizard',
                'verbose_name_plural': 'Setup Wizards',
                'db_table': 'books_setupwizard',
            },
        ),
        migrations.CreateModel(
            name='UserProfile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('theme', models.CharField(choices=[('flatly', 'Flatly'), ('cosmo', 'Cosmo'), ('bootstrap', 'Bootstrap Default'), ('cerulean', 'Cerulean'), ('cyborg', 'Cyborg'), ('darkly', 'Darkly'), ('journal', 'Journal'), ('litera', 'Litera'), ('lumen', 'Lumen'), ('lux', 'Lux'), ('materia', 'Materia'), ('minty', 'Minty'), ('morph', 'Morph'), ('pulse', 'Pulse'), ('quartz', 'Quartz'), ('sandstone', 'Sandstone'), ('simplex', 'Simplex'), ('sketchy', 'Sketchy'), ('slate', 'Slate'), ('solar', 'Solar'), ('spacelab', 'Spacelab'), ('superhero', 'Superhero'), ('united', 'United'), ('vapor', 'Vapor'), ('yeti', 'Yeti'), ('zephyr', 'Zephyr')], default='flatly', help_text='Selected Bootswatch theme', max_length=20)),
                ('items_per_page', models.IntegerField(default=50, help_text='Number of items to show per page')),
                ('show_covers_in_list', models.BooleanField(default=True, help_text='Show book covers in list views')),
                ('default_view_mode', models.CharField(choices=[('table', 'Table'), ('grid', 'Grid')], default='table', help_text='Default view mode for lists', max_length=10)),
                ('share_reading_progress', models.BooleanField(default=False, help_text='Share reading progress with other users')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='profile', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'User Profile',
                'verbose_name_plural': 'User Profiles',
                'db_table': 'books_userprofile',
            },
        ),
        migrations.CreateModel(
            name='AIFeedback',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('original_filename', models.CharField(help_text='Original filename used for AI prediction', max_length=500)),
                ('ai_predictions', models.TextField(help_text='JSON of AI predictions for each field')),
                ('prediction_confidence', models.FloatField(blank=True, help_text='Overall AI prediction confidence', null=True)),
                ('user_corrections', models.TextField(help_text='JSON of user corrections to AI predictions')),
                ('feedback_rating', models.IntegerField(choices=[(1, 'Poor - Completely wrong'), (2, 'Fair - Some correct elements'), (3, 'Good - Mostly correct'), (4, 'Very Good - Almost perfect'), (5, 'Excellent - Perfect prediction')], help_text='User rating of AI prediction quality')),
                ('comments', models.TextField(blank=True, help_text='Additional user feedback or comments')),
                ('needs_retraining', models.BooleanField(default=True, help_text='Whether this feedback should be used for retraining')),
                ('processed_for_training', models.BooleanField(default=False, help_text='Whether this feedback was used in training')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
                ('book', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='ai_feedback', to='books.book')),
            ],
            options={
                'db_table': 'books_aifeedback',
                'ordering': ['-created_at'],
                'unique_together': {('book', 'user')},
            },
        ),
        migrations.CreateModel(
            name='BookTitle',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('confidence', models.FloatField(default=1.0, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('is_active', models.BooleanField(default=True, help_text='Uncheck to hide this metadata without deleting it.')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('title', models.CharField(max_length=500)),
                ('book', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='titles', to='books.book')),
                ('source', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='books.datasource')),
            ],
            options={
                'ordering': ['-confidence'],
                'unique_together': {('book', 'title', 'source')},
            },
            bases=(books.mixins.sync.FinalMetadataSyncMixin, models.Model),
        ),
        migrations.CreateModel(
            name='BookMetadata',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('confidence', models.FloatField(default=1.0, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('is_active', models.BooleanField(default=True, help_text='Uncheck to hide this metadata without deleting it.')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('field_name', models.CharField(max_length=100)),
                ('field_value', models.TextField()),
                ('field_value_hash', models.CharField(editable=False, max_length=64)),
                ('book', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='metadata', to='books.book')),
                ('source', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='books.datasource')),
            ],
            options={
                'ordering': ['-confidence'],
                'unique_together': {('book', 'field_name', 'field_value_hash', 'source')},
            },
            bases=(books.mixins.sync.FinalMetadataSyncMixin, models.Model),
        ),
        migrations.CreateModel(
            name='BookCover',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('confidence', models.FloatField(default=1.0, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('is_active', models.BooleanField(default=True, help_text='Uncheck to hide this metadata without deleting it.')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('cover_path', models.CharField(help_text='Local file path or URL', max_length=1000)),
                ('cover_path_hash', models.CharField(editable=False, max_length=64)),
                ('width', models.IntegerField(blank=True, null=True)),
                ('height', models.IntegerField(blank=True, null=True)),
                ('file_size', models.BigIntegerField(blank=True, null=True)),
                ('format', models.CharField(blank=True, help_text='jpg, png, gif, etc.', max_length=10)),
                ('is_high_resolution', models.BooleanField(default=False)),
                ('aspect_ratio', models.FloatField(blank=True, null=True)),
                ('book', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='covers', to='books.book')),
                ('source', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='books.datasource')),
            ],
            options={
                'ordering': ['-confidence', '-is_high_resolution', '-width'],
                'unique_together': {('book', 'cover_path_hash', 'source')},
            },
            bases=(books.mixins.sync.FinalMetadataSyncMixin, models.Model),
        ),
        migrations.CreateModel(
            name='BookAuthor',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('confidence', models.FloatField(default=1.0, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('is_active', models.BooleanField(default=True, help_text='Uncheck to hide this metadata without deleting it.')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('is_main_author', models.BooleanField(default=False)),
                ('author', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='books.author')),
                ('book', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='bookauthor', to='books.book')),
                ('source', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='books.datasource')),
            ],
            options={
                'ordering': ['-confidence', '-is_main_author'],
                'unique_together': {('book', 'author', 'source')},
            },
            bases=(books.mixins.sync.FinalMetadataSyncMixin, models.Model),
        ),
        migrations.CreateModel(
            name='BookGenre',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('confidence', models.FloatField(validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('is_active', models.BooleanField(default=True, help_text='Uncheck to hide this without deleting it.')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('book', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='bookgenre', to='books.book')),
                ('source', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='books.datasource')),
                ('genre', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='books.genre')),
            ],
            options={
                'unique_together': {('book', 'genre', 'source')},
            },
        ),
        migrations.CreateModel(
            name='BookPublisher',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('confidence', models.FloatField(default=1.0, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('is_active', models.BooleanField(default=True, help_text='Uncheck to hide this metadata without deleting it.')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('book', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='bookpublisher', to='books.book')),
                ('source', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='books.datasource')),
                ('publisher', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='publisher_books', to='books.publisher')),
            ],
            options={
                'ordering': ['-confidence'],
                'unique_together': {('book', 'publisher', 'source')},
            },
            bases=(books.mixins.sync.FinalMetadataSyncMixin, models.Model),
        ),
        migrations.CreateModel(
            name='ScanHistory',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('job_id', models.CharField(help_text='Unique job identifier', max_length=100, unique=True)),
                ('scan_type', models.CharField(choices=[('scan', 'Initial Scan'), ('rescan', 'Rescan'), ('resume', 'Resume Scan')], default='scan', max_length=20)),
                ('folder_path', models.TextField(help_text='Path of the scanned folder')),
                ('folder_name', models.CharField(help_text='Name of the scanned folder', max_length=255)),
                ('status', models.CharField(choices=[('completed', 'Completed Successfully'), ('failed', 'Failed'), ('cancelled', 'Cancelled'), ('partial', 'Partially Completed')], max_length=20)),
                ('started_at', models.DateTimeField(help_text='When the scan started')),
                ('completed_at', models.DateTimeField(help_text='When the scan finished')),
                ('duration_seconds', models.IntegerField(help_text='Total scan duration in seconds')),
                ('total_files_found', models.IntegerField(default=0, help_text='Total files discovered')),
                ('files_processed', models.IntegerField(default=0, help_text='Files successfully processed')),
                ('files_skipped', models.IntegerField(default=0, help_text='Files skipped (already processed)')),
                ('files_failed', models.IntegerField(default=0, help_text='Files that failed processing')),
                ('books_added', models.IntegerField(default=0, help_text='New books added')),
                ('books_updated', models.IntegerField(default=0, help_text='Existing books updated')),
                ('books_removed', models.IntegerField(default=0, help_text='Books marked as removed')),
                ('warnings_count', models.IntegerField(default=0, help_text='Number of warnings encountered')),
                ('errors_count', models.IntegerField(default=0, help_text='Number of errors encountered')),
                ('external_apis_used', models.BooleanField(default=False, help_text='Whether external APIs were queried')),
                ('api_requests_made', models.IntegerField(default=0, help_text='Number of API requests made')),
                ('error_message', models.TextField(blank=True, help_text='Error message if scan failed', null=True)),
                ('summary', models.TextField(blank=True, help_text='Human-readable summary of scan results', null=True)),
                ('metadata_json', models.JSONField(default=dict, help_text='Additional scan metadata and statistics')),
                ('scan_folder', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='books.scanfolder')),
            ],
            options={
                'verbose_name': 'Scan History Entry',
                'verbose_name_plural': 'Scan History Entries',
                'ordering': ['-completed_at', '-started_at'],
                'indexes': [models.Index(fields=['job_id'], name='books_scanh_job_id_b6152e_idx'), models.Index(fields=['status'], name='books_scanh_status_ec3f7c_idx'), models.Index(fields=['completed_at'], name='books_scanh_complet_16ae4b_idx')],
            },
        ),
        migrations.CreateModel(
            name='ScanQueue',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(help_text='Name/description of the scan job', max_length=200)),
                ('scan_type', models.CharField(choices=[('folder', 'Folder Scan'), ('book_ids', 'Specific Book IDs'), ('series', 'Series Scan'), ('author', 'Author Scan'), ('full', 'Full Library Scan'), ('incremental', 'Incremental Scan')], default='folder', max_length=20)),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('scheduled', 'Scheduled'), ('processing', 'Processing'), ('completed', 'Completed'), ('failed', 'Failed'), ('cancelled', 'Cancelled')], default='pending', max_length=20)),
                ('priority', models.IntegerField(choices=[(1, 'Low'), (2, 'Normal'), (3, 'High'), (4, 'Urgent')], default=2, help_text='Scan priority (higher = more urgent)')),
                ('folder_paths', models.JSONField(blank=True, default=list, help_text='List of folder paths to scan')),
                ('book_ids', models.JSONField(blank=True, default=list, help_text='List of specific book IDs to process')),
                ('series_names', models.JSONField(blank=True, default=list, help_text='List of series names to scan')),
                ('author_names', models.JSONField(blank=True, default=list, help_text='List of author names to scan')),
                ('rescan_existing', models.BooleanField(default=False, help_text='Re-scan books that already exist')),
                ('update_metadata', models.BooleanField(default=True, help_text='Update metadata for existing books')),
                ('fetch_covers', models.BooleanField(default=True, help_text='Fetch cover images')),
                ('deep_scan', models.BooleanField(default=False, help_text='Perform deep content analysis')),
                ('scheduled_for', models.DateTimeField(blank=True, help_text='When to execute this scan', null=True)),
                ('estimated_files', models.IntegerField(default=0, help_text='Estimated number of files to process')),
                ('estimated_duration', models.IntegerField(default=0, help_text='Estimated duration in seconds')),
                ('actual_scan_job_id', models.CharField(blank=True, help_text='Job ID when scan starts executing', max_length=50)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('started_at', models.DateTimeField(blank=True, null=True)),
                ('completed_at', models.DateTimeField(blank=True, null=True)),
                ('error_message', models.TextField(blank=True, help_text='Error details if scan failed')),
                ('retry_count', models.IntegerField(default=0, help_text='Number of times this scan has been retried')),
                ('max_retries', models.IntegerField(default=3, help_text='Maximum number of retry attempts')),
                ('created_by', models.ForeignKey(help_text='User who created this queue item', on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Scan Queue Item',
                'verbose_name_plural': 'Scan Queue',
                'ordering': ['-priority', 'created_at'],
                'indexes': [models.Index(fields=['status', 'priority'], name='books_scanq_status_1b7f17_idx'), models.Index(fields=['scan_type'], name='books_scanq_scan_ty_689642_idx'), models.Index(fields=['scheduled_for'], name='books_scanq_schedul_6184bc_idx'), models.Index(fields=['created_by'], name='books_scanq_created_cd5f91_idx')],
            },
        ),
        migrations.CreateModel(
            name='BookSeries',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('confidence', models.FloatField(default=1.0, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('is_active', models.BooleanField(default=True, help_text='Uncheck to hide this metadata without deleting it.')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('series_number', models.CharField(blank=True, max_length=20, null=True)),
                ('book', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='series_info', to='books.book')),
                ('source', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='books.datasource')),
                ('series', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='books.series')),
            ],
            options={
                'verbose_name_plural': 'Book Series',
                'ordering': ['-confidence'],
                'unique_together': {('book', 'series', 'source')},
            },
            bases=(books.mixins.sync.FinalMetadataSyncMixin, models.Model),
        ),
    ]
